:orphan:

..  Copyright (C) Jackie Cohen, Stephen Oney, Paul Resnick.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Activities through 11/27 (Through T-Giving Break)
=================================================

* **By Monday 11/21:**

  * Read the :ref:`Recursion <recursion_chap>` chapter and try the included exercises. This is some of the most challenging, intellectually advanced (and blow-your mind cool and interesting) material you will see this semester. Reading about it before the class session on Monday will be really helpful.
  * You may want to review :ref:`Python modules <modules_chap>`. This week in the problem set, you will be using an external module that we have provided as a file that you will put in the same directory as the file you are running.

.. usageassignment::
  :subchapters: Recursion/WhatIsRecursion, Recursion/CalculatingtheSumofaListofNumbers, Recursion/TheThreeLawsofRecursion, Recursion/ConvertinganIntegertoaStringinAnyBase, Recursion/intro-VisualizingRecursion, Recursion/SierpinskiTriangle 
  :assignment_name: Prep 20
  :deadline: 2016-11-28 22:40
  :pct_required: 65
  :points: 50


* **No class Wednesday 11/23.** Also no discussion section this week, and no office hours during Thanksgiving break, although staff will be online intermittently to post on the FB group and so on!

* **Before Sunday 11/27 at 11:59 PM:**

  * Complete :ref:`Reading Response 11 <reading_response_11>`.

* **Before class Monday 11/28, after Thanksgiving break:** Turn in your `Final Project plan <https://umich.instructure.com/courses/108426/assignments/139250>`_ on Canvas!


* PS 10, on Recursion, is not due Sunday 11/27, it is due **Sunday, 12/4** at 11:59 PM. 
* Next week, we will release another problem set, which will be *optional.* It will be especially interesting for HCI-oriented students who want to understand the architecture of how event-driven interactive GUIs are programmed. You'll learn more about that soon. That will also be due (if you choose to do it) on **Sunday, 12/4**.
* Your next DYU will *also* be due Sunday 12/4 at 11:59 PM. You can look ahead on Canvas to do these if you wish, and we will also be posting the *following* week of material shortly, on event-drive interactive GUIs.

* **The only assignments due immediately after Thanksgiving break are your Final Project plan and a reading response.** However, it is probably a good idea to look at this problem set as soon as you can so you can prepare/arrange your next two weeks of work for this class!

This Week's Reading Responses
-----------------------------

.. _reading_response_11:

.. external:: rr_11

  `Reading Response 11 <https://umich.instructure.com/courses/108426/assignments/139260>`_ on Canvas.


.. _problem_set_10:

Problem Set
-----------

Go `HERE to see the Problem Set 10 assignment <https://umich.instructure.com/courses/108426/assignments/139251>`_, where you can find direction to the files you need to download and edit, and where you can submit your file for this assignment.

.. note::

  Reminder: we do not debug code when grading, so we cannot grade code that does not run! Make sure your code runs before submitting it -- you should comment out any code that does not.

.. external:: ps_10_preamble

  **IMPORTANT PREAMBLE**

  For this problem set, we have provided 2 files: ``506_ps10.py``, your usual code file to edit, and ``os_506.py``.

  ``os_506`` is an external module you'll be using in your problem set -- you can see that your code file imports ``os_506`` at the top. But it's one you'll save in the same directory, rather than one you install with pip. 

  This module provides a 'fake file system' for you to run the code on your problem set with. That is, there are some 'simulated' directories and subdirectories and file names and file sizes.  You'll be writing code that can actually get information about your computer's file system, *but* in order to test it, make the problem set easy, make sure everyone's answers are the same, and ensure that you can't hurt your computer while you try stuff out, we're using **os_506** instead of the raw **os** module which allows you to interact with the files on your computer. At the end of the problem set, we encourage you to change the value of one variable, so that your functions will run against your computer's file system, rather than the fake one.


  **You should not change ANY code in the os_506 file. It's very important that it stay exactly as you download it, the problem set depends on it! You also should not submit it to Canvas -- we will already have it when we run your submitted problem set.**

You do not have to read the code in ``os_506.py``, though you are welcome to look at if you want. Like other modules you have imported, you can understand it just by understanding the functions that it makes available to you.


-  ``join`` - takes two parts of a file system path and joins them according to the operating system's conventions. example: ``join('/users/soney', 'myProg.py')`` -> ``'/users/soney/myProg.py'``. On Windows, it might use ``\`` or ``\\`` instead of ``/`` as the character in between the two joined parts.

- ``splitext`` - will separate an extension from a file name. For example, the invocation ``os.path.splitext('/usr/soney/file.txt')`` returns ``('/usr/soney/file', '.txt')``

- ``listdir(path)`` - returns a list of all the filenames in a directory, given a string representing a path to a directory.

- ``isfile(path)`` - returns True if the given path points to a file (not a directory)

- ``isdir(path)`` - returns True if the given path points to a directory (not a file)

- ``getsize(path)`` - returns the numeric size (in bytes) of a file. It only works if isfile(path) returns True.

.. note::

    In order to invoke any of these functions inside your problem set file, you'll need to have saved ``os_506.py`` in the same directory, and precede the invocations with that name, e.g. ``os_506.listdir('/usr/soney')``.

There is also one variable defined in the module that you will use.

- ``USE_REAL_FILESTYSTEM``. When this is set to True, the operations in the module will use the computer's real file system. When it is set to False, it will use the fake filesystem.

Below you can see the directory and file structure in the fake (simulated) file system. For example, there is a file detroit.jpg (size 800) in the directory /Users/steve/Images/. The full path to it would be ``/Users/steve/Images/detroit.jpg``. If you called ``os_506.getsize(/Users/steve/Images/detroit.jpg)`` you would get a return value of 800. ::

    Applications/:
        Atom.app/:
            (empty)
        Sublime.app/:
            (empty)
    Users/:
        steve/:
            Images/:
                detroit.jpg: 800
                michigan_stadium.jpeg: 1000
            Movies/:
                convocation.mov: 60000
                graduation.mov: 80000
            Desktop/:
                506/:
                    ps10.py: 110
                106/:
                    ps10.py: 100
        paul/:
            Images/:
                heinz_field.jpg: 900
            code/:
                runestone/:
                    runestone_client.js: 599
            Papers/:
                paper1.pdf: 120
                paper6.pdf: 140
                paper3.pdf: 130
        jackie/:
            Documents/:
                finalexam1.docx: 600
    106_solutions/:
        (empty)
    ps10_solution.py: 500
    506_solutions/:
        (empty)

.. external:: ps_10_01
  
  **PROBLEM 1**

  Warm up: this problem doesn't use the file system operations. Fill in the definition of the ``sum`` function. It should accept a list of numbers, and return their sum.Your implementation may or may not be recursive (but it should not use the built in ``sum`` function in Python).

.. external:: ps_10_02
  
  **PROBLEM 2**

  We've provided a dictionary ``extension_types``: 

  .. sourcecode:: python

    extensionTypes = {
    'movie': ['.mp4','.mov'],
    'image': ['.jpg','.jpeg','.png','.bmp','.svg'],
    'document': ['.docx','.pdf','.txt'],
    'code': ['.py','.python','.java','.js']
    }

  The keys in ``extensionTypes`` are broad media categories that could be on a computer. The values associated with those keys are *lists* of strings: file extensions that fall under those media categories.

  In this problem, you should complete a definition of the ``getFileType`` function, which accepts as input a ``path`` string, which should be a full path to a *file* (not a directory), and returns the string representing the media category that that file falls into (based on the ``extensionTypes`` declared above). Your implementation should not be recursive -- this function is a tool for the recursive function you will write later.

  Note that the ``os_506.splitext`` function will separate an extension from a file name. For example, the invocation ``os.path.splitext('/usr/soney/file.txt')`` returns ``('/usr/soney/file', '.txt')`` -- this may be useful to you here!

  We've provided some code that uses this to start out your function definition with, as follows:

  .. sourcecode:: python

    def getFileType(path):
        filename,extension = os_506.splitext(path)

        # TODO: Fill this in!

        # If we can't find a matching category, return 'unknown' as a default
        return 'unknown'


.. external:: ps_10_03
  
  **PROBLEM 3**

  Now, finish the definition of a ``getSize`` function that accepts a string ``path`` as a full path to a file OR directory, and returns the numeric **size** (the number of bytes) of that file or directory, including all subdirectories.

  This function must be recursive.

  The base case is where the path is to a single file, in which case you return its size.

  The recursive case occurs when the input path is to a directory, in which case you'll need to get the sizes of all files and subdirectories inside that directory, and add them up.

  **Hint:** the function provided in our ``os_506`` module, ``os_506.getsize``, which returns the number of bytes a file contains, is useful here, as may be the ``sum`` function you defined earlier.

  We have provided the code for the base case -- you just need to fill in the code for the recursive case beneath the line ``elif os_506.isdir(path): # recursive case``.

  You do not have to use the list comprehension we've provided, but it may make things easier! Try to figure out what that list comprehensions produces, as that will help you understand why it will be useful to you. It may help you to add a print statement to see what it produces with various paths as input.

.. external:: ps_10_04
  
  **PROBLEM 4**

  Write a `getCategorySizes` function that accepts 'path' as a full path to a file OR directory and returns a dictionary whose keys are file types that appear (use ``getFileType`` to find those!) and whose values are the **total size** of files (i.e., the sum of sizes) of that file type.

  For example,
  ``getCategorySizes('/Users/steve')`` might return ``{'movie': 140000, 'image': 1800, 'code': 210}``.

  We have provided some code AND some English for you. You'll need to translate the English into code inside the function definition in order to complete it. Some general hints about writing this function:

  Accumulate a dictionary called bins as you recursively visit all the files in the directory and subdirectories. Each key in the ``bins`` dictionary will be one file type. The associated value for each key will be the sum of the filesizes of all files of that type. (Don't forget to pass the ``bins`` dictionary on each recursive call to ``getCategorySizes``!)

.. external:: ps_10_05
  
  **PROBLEM 5 (OPTIONAL, not graded!)**
  
  All our tests use the "fake" filesystem, provided in the ``os_506`` module. Now that you have your code working, you can have some fun running on your actual filesystem.

  Uncomment the line (provided in the code file): ``os_506.USE_REAL_FILESTYSTEM = True``.

  Call ``getCategorySizes`` and/or ``getSize`` on some of your directory paths, and print out the results! Suggestion: *don't* call ``getSize('/')`` unless you are prepared to wait a long time for the answer!

  **Note:** if you have a directory with a really large number of files, and you implemented the sum function recursively, you may get an error when you run ``getSize`` on that directory. If that happens, try a directory with fewer files.